<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Othello × LifeGame（CCC / Local v10）</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
      display: grid;
      place-items: center;
      min-height: 100vh;
    }
    .app { width: min(1060px, 96vw); display: grid; gap: 12px; padding: 14px 0; }

    .panel {
      border: 1px solid rgba(127,127,127,.35);
      border-radius: 14px;
      padding: 12px;
      background: rgba(127,127,127,.06);
    }

    .topbar { display: grid; gap: 10px; }
    .toprow {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .title { font-weight: 800; font-size: 16px; line-height: 1.2; }
    .hint { opacity: .75; font-size: 12px; }

    button, input {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.12);
    }
    button { cursor: pointer; }
    button:hover { filter: brightness(1.1); }
    input[type="number"] { width: 110px; }

    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.12);
      font-size: 13px;
    }

    .scoregrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 720px) { .scoregrid { grid-template-columns: 1fr; } }

    .playerCard {
      border-radius: 14px;
      padding: 12px;
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.08);
      display: grid;
      gap: 10px;
    }

    .playerHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.12);
      font-size: 13px;
    }
    .dot {
      width: 12px; height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(127,127,127,.35);
    }
    .dot.black { background: #111; }
    .dot.white { background: #f0f0f0; }

    .kv {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 12px;
      align-items: baseline;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(127,127,127,.25);
      background: rgba(0,0,0,.10);
    }
    .k { opacity: .85; font-size: 12px; }
    .v { font-weight: 900; font-size: 18px; letter-spacing: .2px; }

    .turnBanner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(127,127,127,.25);
      background: rgba(0,0,0,.12);
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 14px;
      border: 1px solid rgba(127,127,127,.35);
      background: #0b0b0b;
      touch-action: none;
    }
    #log { white-space: pre-wrap; line-height: 1.5; font-size: 13px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel topbar">
      <div class="toprow">
        <div>
          <div class="title">Othello × LifeGame（CCC / ローカル対戦）</div>
          <div class="hint">クリックで石を置く / R: リセット（配置も再抽選） / 置ける場所は黒い点（最前面） / 座標はチェス形式（上下a-h / 左右8-1）</div>
        </div>
        <div class="row">
          <button id="btnReset">Reset</button>
        </div>
      </div>

      <div class="row">
        <span class="pill">罰ゲームマス数（0〜16）</span>
        <input id="penaltyCount" type="number" min="0" max="16" step="1" value="10" />
        <button id="btnPenaltyRandom">ランダム</button>
        <span class="hint">※過不足は「+10（青）」の枚数で調整（最大16）。</span>
      </div>

      <div class="turnBanner">
        <div class="badge">
          <span>手番</span>
          <span id="turnLabel" style="font-weight:900;">黒</span>
        </div>
        <div class="hint">
          合算 = 所持金 + 石数×<span id="discBonusLabel">10</span> /
          罰ゲーム: 黄 / 正: 青（数値のみ） / 負: 赤（数値のみ）
        </div>
      </div>

      <div class="scoregrid">
        <div class="playerCard" aria-label="black player">
          <div class="playerHeader">
            <span class="badge"><span class="dot black"></span><strong>黒</strong></span>
            <span class="hint" id="blackTurnHint"></span>
          </div>
          <div class="kv">
            <div class="k">石の枚数</div><div class="v" id="blackDiscs">2</div>
            <div class="k">所持金</div><div class="v" id="blackMoney">0</div>
            <div class="k">総合得点（合算）</div><div class="v" id="blackTotal">20</div>
          </div>
        </div>

        <div class="playerCard" aria-label="white player">
          <div class="playerHeader">
            <span class="badge"><span class="dot white"></span><strong>白</strong></span>
            <span class="hint" id="whiteTurnHint"></span>
          </div>
          <div class="kv">
            <div class="k">石の枚数</div><div class="v" id="whiteDiscs">2</div>
            <div class="k">所持金</div><div class="v" id="whiteMoney">0</div>
            <div class="k">総合得点（合算）</div><div class="v" id="whiteTotal">20</div>
          </div>
        </div>
      </div>
    </div>

    <canvas id="game" width="920" height="920" aria-label="othello board"></canvas>

    <div class="panel" id="log"></div>
  </div>

  <script>
    "use strict";

    // =========================
    // Config
    // =========================
    const N = 8;
    const DISC_BONUS = 10;

    const TILE = { NONE: 0, PENALTY: 1, POS: 2, NEG: 3 };

    const POS_BASE = [
      { value: 100, count: 1 },
      { value: 80,  count: 2 },
      { value: 70,  count: 3 },
      { value: 50,  count: 4 },
      { value: 30,  count: 5 },
    ];

    // Popup timing (hold varies, fade fixed)
    const POPUP_FADE_MS = 1200;
    const HOLD_NEUTRAL_MS = 1200;
    const HOLD_POSNEG_MS = 1440;
    const HOLD_PENALTY_MS = 6000;

    // Coordinate / layout
    const PAD = 18;                 // reduced
    const LABEL_MARGIN = 34;        // reduced (less empty corner space)
    const FILES = ["a","b","c","d","e","f","g","h"];
    const RANKS = ["8","7","6","5","4","3","2","1"];

    // =========================
    // UI
    // =========================
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      reset: document.getElementById("btnReset"),
      penaltyCount: document.getElementById("penaltyCount"),
      penaltyRandom: document.getElementById("btnPenaltyRandom"),

      turnLabel: document.getElementById("turnLabel"),
      discBonusLabel: document.getElementById("discBonusLabel"),

      blackDiscs: document.getElementById("blackDiscs"),
      whiteDiscs: document.getElementById("whiteDiscs"),
      blackMoney: document.getElementById("blackMoney"),
      whiteMoney: document.getElementById("whiteMoney"),
      blackTotal: document.getElementById("blackTotal"),
      whiteTotal: document.getElementById("whiteTotal"),

      blackTurnHint: document.getElementById("blackTurnHint"),
      whiteTurnHint: document.getElementById("whiteTurnHint"),

      log: document.getElementById("log"),
    };
    ui.discBonusLabel.textContent = String(DISC_BONUS);

    // =========================
    // Game State
    // =========================
    let board;
    let tiles;
    let money;
    let turn;
    let gameOver = false;

    // Popup: Hold + Fade
    let popup = {
      text: "",
      theme: "neutral",
      start: 0,
      holdMs: HOLD_NEUTRAL_MS,
      fadeMs: POPUP_FADE_MS,
      holdUntil: 0,
      endAt: 0,
    };

    function showPopup(text, theme, holdMs) {
      const now = performance.now();
      popup.text = text;
      popup.theme = theme;
      popup.start = now;
      popup.holdMs = holdMs;
      popup.fadeMs = POPUP_FADE_MS;
      popup.holdUntil = now + holdMs;
      popup.endAt = popup.holdUntil + popup.fadeMs;
    }

    function other(p) { return p === 1 ? 2 : 1; }
    function inBounds(x, y) { return x >= 0 && x < N && y >= 0 && y < N; }
    function log(msg) { ui.log.textContent = msg; }

    // =========================
    // Othello logic
    // =========================
    const DIRS = [
      [-1,-1],[0,-1],[1,-1],
      [-1, 0],      [1, 0],
      [-1, 1],[0, 1],[1, 1],
    ];

    function getFlipsForMove(p, x, y) {
      if (!inBounds(x, y) || board[y][x] !== 0) return [];
      const opp = other(p);
      const flips = [];
      for (const [dx, dy] of DIRS) {
        let cx = x + dx, cy = y + dy;
        const line = [];
        while (inBounds(cx, cy) && board[cy][cx] === opp) {
          line.push([cx, cy]);
          cx += dx; cy += dy;
        }
        if (line.length > 0 && inBounds(cx, cy) && board[cy][cx] === p) {
          flips.push(...line);
        }
      }
      return flips;
    }

    function hasAnyMove(p) {
      for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
        if (board[y][x] !== 0) continue;
        if (getFlipsForMove(p, x, y).length > 0) return true;
      }
      return false;
    }

    function countDiscs() {
      let b = 0, w = 0;
      for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
        if (board[y][x] === 1) b++;
        else if (board[y][x] === 2) w++;
      }
      return { b, w };
    }

    function totalScore(p, discsCount) {
      const discs = (p === 1) ? discsCount.b : discsCount.w;
      return money[p] + discs * DISC_BONUS;
    }

    // =========================
    // Utilities
    // =========================
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function clampInt(v, min, max) {
      const n = Number(v);
      if (!Number.isFinite(n)) return min;
      return Math.max(min, Math.min(max, Math.trunc(n)));
    }

    // =========================
    // Layout (board center == canvas center) + Popup center == board center
    // =========================
    function getLayout() {
      const W = canvas.width, H = canvas.height;

      // Reserve equally on all sides by design. Board + labels square is centered.
      const totalSide = Math.min(W, H) - PAD * 2;         // square area we use
      const size = totalSide - LABEL_MARGIN * 2;          // board size inside labels
      const cell = size / N;

      const ox = (W - totalSide) / 2 + PAD;               // top-left of label+board square
      const oy = (H - totalSide) / 2 + PAD;

      const bx = ox + LABEL_MARGIN;                       // top-left of board itself
      const by = oy + LABEL_MARGIN;

      const centerX = bx + size / 2;
      const centerY = by + size / 2;

      return { W, H, totalSide, size, cell, ox, oy, bx, by, centerX, centerY };
    }

    // =========================
    // Tile Placement
    // =========================
    function initTiles(penaltyCountRaw) {
      const penaltyCount = clampInt(penaltyCountRaw, 0, 16);

      tiles = Array.from({ length: N }, () => Array.from({ length: N }, () => ({
        type: TILE.NONE,
        value: 0,
        consumed: false,
      })));

      const forbidden = new Set([`3,3`,`4,4`,`3,4`,`4,3`]);

      const cornerCells = [];
      const addBlock = (sx, sy) => {
        for (let y = sy; y < sy + 2; y++) for (let x = sx; x < sx + 2; x++) {
          if (!forbidden.has(`${x},${y}`)) cornerCells.push([x, y]);
        }
      };
      addBlock(0, 0);
      addBlock(N - 2, 0);
      addBlock(0, N - 2);
      addBlock(N - 2, N - 2);

      shuffle(cornerCells);
      const selectedPenalty = cornerCells.slice(0, penaltyCount);

      const used = new Set();
      for (const [x, y] of selectedPenalty) {
        tiles[y][x] = { type: TILE.PENALTY, value: 0, consumed: false };
        used.add(`${x},${y}`);
      }

      const remainingCount = 60 - penaltyCount;
      const posCount = Math.ceil(remainingCount / 2);
      const negCount = remainingCount - posCount;

      let posBaseTotal = 0;
      const posList = [];
      for (const item of POS_BASE) {
        for (let i = 0; i < item.count; i++) posList.push(+item.value);
        posBaseTotal += item.count;
      }

      let plus10Count = posCount - posBaseTotal;
      if (plus10Count < 0) plus10Count = 0;
      for (let i = 0; i < plus10Count; i++) posList.push(10);

      shuffle(posList);
      const posFinal = posList.slice(0, posCount);

      const negList = posFinal.map(v => -v);
      shuffle(negList);
      const negFinal = negList.slice(0, negCount);

      const remainingCells = [];
      for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
        const key = `${x},${y}`;
        if (forbidden.has(key)) continue;
        if (used.has(key)) continue;
        remainingCells.push([x, y]);
      }
      shuffle(remainingCells);

      for (let i = 0; i < posFinal.length; i++) {
        const [x, y] = remainingCells[i];
        tiles[y][x] = { type: TILE.POS, value: posFinal[i], consumed: false };
      }
      for (let i = 0; i < negFinal.length; i++) {
        const [x, y] = remainingCells[i + posFinal.length];
        tiles[y][x] = { type: TILE.NEG, value: negFinal[i], consumed: false };
      }

      return { penaltyCount, posCount, negCount, plus10Count };
    }

    function applyTileEffect(p, x, y) {
      const t = tiles[y][x];
      if (!t || t.type === TILE.NONE || t.consumed) return null;

      t.consumed = true;

      if (t.type === TILE.POS || t.type === TILE.NEG) {
        money[p] += t.value;
        return { type: t.type, value: t.value };
      }
      if (t.type === TILE.PENALTY) {
        return { type: t.type, value: 0 };
      }
      return null;
    }

    // =========================
    // Text fitting
    // =========================
    function fitFontSizeToBox(text, maxWidth, maxHeight, fontFamily = "system-ui") {
      let lo = 6;
      let hi = Math.floor(maxHeight);
      let best = lo;

      while (lo <= hi) {
        const mid = Math.floor((lo + hi) / 2);
        ctx.font = `900 ${mid}px ${fontFamily}`;
        const w = ctx.measureText(text).width;
        const h = mid * 1.05;

        if (w <= maxWidth && h <= maxHeight) { best = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }
      return best;
    }

    // =========================
    // Rendering
    // =========================
    function draw() {
      const { W, H, size, cell, bx, by } = getLayout();

      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "#0b0b0b";
      ctx.fillRect(0, 0, W, H);

      // board base
      ctx.fillStyle = "#145a32";
      ctx.fillRect(bx, by, size, size);

      // tile fills
      for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
        const t = tiles[y][x];
        if (!t || t.type === TILE.NONE) continue;

        const rx = bx + x * cell;
        const ry = by + y * cell;
        const dim = t.consumed ? 0.45 : 0.85;

        if (t.type === TILE.PENALTY) ctx.fillStyle = `rgba(255, 215, 0, ${dim})`;
        else if (t.type === TILE.POS) ctx.fillStyle = `rgba(0, 102, 204, ${dim})`;
        else ctx.fillStyle = `rgba(204, 0, 0, ${dim})`;

        ctx.fillRect(rx, ry, cell, cell);
      }

      // grid
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.lineWidth = 2;
      for (let i = 0; i <= N; i++) {
        const x = bx + i * cell;
        const y = by + i * cell;
        ctx.beginPath(); ctx.moveTo(x, by); ctx.lineTo(x, by + size); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx, y); ctx.lineTo(bx + size, y); ctx.stroke();
      }

      // coordinates on all four sides
      drawCoordinatesAllSides(bx, by, size, cell);

      // tile text
      for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
        const t = tiles[y][x];
        if (!t || t.type === TILE.NONE) continue;

        const cx = bx + x * cell + cell / 2;
        const cy = by + y * cell + cell / 2;

        if (t.type === TILE.PENALTY) {
          const text = "罰ゲーム";
          const fontSize = fitFontSizeToBox(text, cell * 0.92, cell * 0.34);
          ctx.font = `900 ${fontSize}px system-ui`;
          ctx.fillStyle = "rgba(0,0,0,0.95)";
          const tw = ctx.measureText(text).width;
          ctx.fillText(text, cx - tw / 2, cy + fontSize * 0.35);
        } else {
          const text = (t.value >= 0) ? `+${t.value}` : `${t.value}`;
          const fontSize = fitFontSizeToBox(text, cell * 0.92, cell * 0.62);
          ctx.font = `900 ${fontSize}px system-ui`;
          ctx.fillStyle = "rgba(255,255,255,0.95)";
          const tw = ctx.measureText(text).width;
          ctx.fillText(text, cx - tw / 2, cy + fontSize * 0.35);
        }
      }

      // discs
      for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
        const v = board[y][x];
        if (v === 0) continue;

        const cx = bx + x * cell + cell / 2;
        const cy = by + y * cell + cell / 2;

        ctx.beginPath();
        ctx.arc(cx + 2, cy + 2, cell * 0.36, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(cx, cy, cell * 0.36, 0, Math.PI * 2);
        ctx.fillStyle = (v === 1) ? "#111" : "#f0f0f0";
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // frame
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.lineWidth = 3;
      ctx.strokeRect(bx, by, size, size);

      // popup overlay (CENTERED on board)
      drawPopupOverlayBoardCentered();

      // legal move dots (frontmost)
      drawLegalMoveDots(bx, by, cell);
    }

    function drawCoordinatesAllSides(bx, by, size, cell) {
      const fontSize = Math.max(13, Math.floor(LABEL_MARGIN * 0.40));

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      ctx.font = `800 ${fontSize}px system-ui`;

      for (let x = 0; x < N; x++) {
        const cx = bx + x * cell + cell / 2;
        ctx.fillText(FILES[x], cx, by - LABEL_MARGIN * 0.58);
        ctx.fillText(FILES[x], cx, by + size + LABEL_MARGIN * 0.58);
      }

      for (let y = 0; y < N; y++) {
        const cy = by + y * cell + cell / 2;
        ctx.fillText(RANKS[y], bx - LABEL_MARGIN * 0.58, cy);
        ctx.fillText(RANKS[y], bx + size + LABEL_MARGIN * 0.58, cy);
      }

      ctx.restore();
    }

    function drawLegalMoveDots(bx, by, cell) {
      if (gameOver) return;

      ctx.fillStyle = "rgba(0,0,0,.80)";
      for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
        if (board[y][x] !== 0) continue;
        const flips = getFlipsForMove(turn, x, y);
        if (flips.length === 0) continue;

        const cx = bx + x * cell + cell / 2;
        const cy = by + y * cell + cell / 2;

        ctx.beginPath();
        ctx.arc(cx, cy, cell * 0.090, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,.25)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawPopupOverlayBoardCentered() {
      const now = performance.now();
      if (!popup.text || now > popup.endAt) return;

      let alpha = 1;
      if (now > popup.holdUntil) {
        const t = (now - popup.holdUntil) / popup.fadeMs;
        alpha = Math.max(0, 1 - t);
      }
      const eased = 1 - Math.pow(1 - alpha, 2);

      const { W, H, size, centerX, centerY } = getLayout();

      // popup size is relative to board size (keeps it visually aligned)
      const boxW = Math.min(560, size * 0.82, W * 0.78);
      const boxH = Math.min(140, size * 0.22, H * 0.18);

      const x = centerX - boxW / 2;
      const y = centerY - boxH / 2;

      let fill = "rgba(0,0,0,0.70)";
      let border = "rgba(255,255,255,0.35)";
      if (popup.theme === "pos") {
        fill = "rgba(10, 60, 140, 0.78)";
        border = "rgba(180, 210, 255, 0.55)";
      } else if (popup.theme === "neg") {
        fill = "rgba(140, 10, 10, 0.78)";
        border = "rgba(255, 200, 200, 0.55)";
      } else if (popup.theme === "penalty") {
        fill = "rgba(160, 120, 0, 0.78)";
        border = "rgba(255, 240, 180, 0.60)";
      }

      ctx.save();
      ctx.globalAlpha = eased;

      ctx.fillStyle = fill;
      ctx.fillRect(x, y, boxW, boxH);

      ctx.strokeStyle = border;
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, boxW, boxH);

      const text = popup.text;
      const maxW = boxW * 0.9;
      const maxH = boxH * 0.55;
      const fontSize = fitFontSizeToBox(text, maxW, maxH);
      ctx.font = `900 ${fontSize}px system-ui`;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, x + (boxW - tw) / 2, y + boxH / 2 + fontSize * 0.35);

      ctx.restore();
    }

    function canvasToCell(px, py) {
      const { bx, by, size, cell } = getLayout();
      if (px < bx || py < by || px > bx + size || py > by + size) return null;
      const x = Math.floor((px - bx) / cell);
      const y = Math.floor((py - by) / cell);
      if (!inBounds(x, y)) return null;
      return { x, y };
    }

    // =========================
    // UI refresh
    // =========================
    function refreshUI(extraMsg = "") {
      const { b, w } = countDiscs();
      ui.turnLabel.textContent = (turn === 1) ? "黒" : "白";
      ui.blackTurnHint.textContent = (turn === 1 && !gameOver) ? "← あなたの手番" : "";
      ui.whiteTurnHint.textContent = (turn === 2 && !gameOver) ? "← あなたの手番" : "";

      ui.blackDiscs.textContent = String(b);
      ui.whiteDiscs.textContent = String(w);
      ui.blackMoney.textContent = String(money[1]);
      ui.whiteMoney.textContent = String(money[2]);

      const bt = totalScore(1, { b, w });
      const wt = totalScore(2, { b, w });
      ui.blackTotal.textContent = String(bt);
      ui.whiteTotal.textContent = String(wt);

      if (gameOver) {
        const winner = bt === wt ? "引き分け" : (bt > wt ? "黒の勝ち" : "白の勝ち");
        log(
          `ゲーム終了。\n` +
          `黒: 所持金 ${money[1]} / 石 ${b} / 合算 ${bt}\n` +
          `白: 所持金 ${money[2]} / 石 ${w} / 合算 ${wt}\n` +
          `結果: ${winner}\n` +
          (extraMsg ? `\n${extraMsg}` : "")
        );
      } else if (extraMsg) {
        log(extraMsg);
      } else {
        log(`手番: ${(turn === 1) ? "黒" : "白"}。置ける場所には黒い点が出ています（最前面）。`);
      }
    }

    // =========================
    // End / Turn advance
    // =========================
    function endIfNoMoves() {
      const bCan = hasAnyMove(1);
      const wCan = hasAnyMove(2);
      const discs = countDiscs();
      const full = discs.b + discs.w === N * N;

      if (full || (!bCan && !wCan)) {
        gameOver = true;
        refreshUI();
        showPopup("ゲーム終了", "neutral", HOLD_NEUTRAL_MS);
        return true;
      }
      return false;
    }

    function advanceTurn(msgAfter = "") {
      const next = other(turn);

      if (hasAnyMove(next)) {
        turn = next;
        refreshUI(msgAfter);
        return;
      }

      if (!hasAnyMove(turn)) {
        gameOver = true;
        refreshUI(msgAfter + (msgAfter ? "\n" : "") + "両者とも置けないため終了。");
        showPopup("ゲーム終了", "neutral", HOLD_NEUTRAL_MS);
        return;
      }

      refreshUI(
        msgAfter +
        (msgAfter ? "\n" : "") +
        `相手（${next === 1 ? "黒" : "白"}）は置けないためパス。あなたの手番続行。`
      );
      showPopup("相手パス", "neutral", HOLD_NEUTRAL_MS);
    }

    // =========================
    // Move
    // =========================
    function tryMove(x, y) {
      if (gameOver) return;

      const flips = getFlipsForMove(turn, x, y);
      if (flips.length === 0) return;

      board[y][x] = turn;
      for (const [fx, fy] of flips) board[fy][fx] = turn;

      const eff = applyTileEffect(turn, x, y);

      const who = (turn === 1) ? "黒" : "白";
      const coord = `${FILES[x]}${8 - y}`;

      let msg =
        `${who}が ${coord} に置いた。ひっくり返し: ${flips.length}枚。\n` +
        `マス効果: `;

      if (!eff) {
        msg += "なし";
        showPopup("効果なし", "neutral", HOLD_NEUTRAL_MS);
      } else if (eff.type === TILE.PENALTY) {
        msg += "罰ゲーム（効果は未設定）";
        showPopup("罰ゲーム", "penalty", HOLD_PENALTY_MS);
      } else {
        const signed = eff.value >= 0 ? `+${eff.value}` : `${eff.value}`;
        msg += `${signed}（所持金に反映）`;
        showPopup(signed, eff.type === TILE.POS ? "pos" : "neg", HOLD_POSNEG_MS);
      }

      draw();
      if (endIfNoMoves()) return;

      advanceTurn(msg);
      draw();
    }

    // =========================
    // Reset
    // =========================
    function reset() {
      const pc = clampInt(ui.penaltyCount.value, 0, 16);
      ui.penaltyCount.value = String(pc);

      board = Array.from({ length: N }, () => Array.from({ length: N }, () => 0));
      board[3][3] = 2; board[4][4] = 2;
      board[3][4] = 1; board[4][3] = 1;

      const info = initTiles(pc);

      money = { 1: 0, 2: 0 };
      turn = 1;
      gameOver = false;

      refreshUI(
        `開始。黒の手番。\n` +
        `罰ゲーム: ${info.penaltyCount} / 正: ${info.posCount}（+10は${info.plus10Count}枚） / 負: ${info.negCount}\n` +
        `Resetでマス配置も再抽選されます。`
      );
      showPopup("START", "neutral", HOLD_NEUTRAL_MS);
      draw();
    }

    // =========================
    // Input
    // =========================
    function getCanvasPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
      const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;

      return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    canvas.addEventListener("click", (e) => {
      const p = getCanvasPos(e);
      const cell = canvasToCell(p.x, p.y);
      if (!cell) return;
      tryMove(cell.x, cell.y);
    });

    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const p = getCanvasPos(e);
      const cell = canvasToCell(p.x, p.y);
      if (!cell) return;
      tryMove(cell.x, cell.y);
    }, { passive: false });

    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "r") reset();
    });

    ui.reset.addEventListener("click", reset);

    ui.penaltyRandom.addEventListener("click", () => {
      ui.penaltyCount.value = String(Math.floor(Math.random() * 17));
      reset();
    });

    // =========================
    // Boot + animation loop
    // =========================
    function loop() {
      const now = performance.now();
      if (popup.text && now <= popup.endAt) draw();
      requestAnimationFrame(loop);
    }

    reset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
